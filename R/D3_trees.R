
create.html.radial.tree <- function(json.file        = NULL,
                                    d3.template      = NULL,
                                    d3.outfile       = NULL,
                                    motif.info       = NULL,
                                    d3.lib           = NULL,
                                    jq.lib           = NULL,
                                    outdir           = NULL,
                                    alignment.length = 20,
                                    html.legend      = NULL,
                                    barplot.ann      = NULL) {
  
  # Read D3 template as an array an iterate over it
  d3.lines <- readLines(d3.template)
  d3.lines.updated <- d3.lines
  d3.line.counter  <- 0
  nb.motifs        <- nrow(motif.info)
  
  for (d3l in d3.lines) {
    
    d3.line.counter <- d3.line.counter + 1
    
    # Update tree width
    if (grepl(pattern = "--radial_w--", x = d3l)) {
      
      # Width is determined by number of motifs
      radial.w <- ifelse(nb.motifs > 200, yes = 2500, no = 2000)
      d3.lines.updated[d3.line.counter] <- gsub(pattern = "--radial_w--", x = d3l, replacement = radial.w)
    }
    
    if (!is.null(html.legend)) {
      if (grepl(pattern = '<!-- legend -->', x = d3l)) {
        d3.lines.updated[d3.line.counter] <- gsub(pattern = '<!-- legend -->', x = d3l, replacement = html.legend)
      }
    }
    
    if (!is.null(barplot.ann)) {
      
      barplot.ann.path <- relpath(path        = barplot.ann,
                                  relative.to = results.main.dir)
      
      barplot.ann.html <- paste0('<a href="', gsub(barplot.ann.path, pattern = "\\.svg", replacement = "\\.html"),'" target="_blank"> <img class="barplot Color_class_table" src="', barplot.ann.path, '" ></a>') 
      
      if (grepl(pattern = '<!-- barplot -->', x = d3l)) {
        d3.lines.updated[d3.line.counter] <- gsub(pattern = '<!-- barplot -->', x = d3l, replacement = barplot.ann.html)
      }
    }
    
    
    # Update tree height
    if (grepl(pattern = "--radial_h--", x = d3l)) {
      
      # Width is determined by number of motifs
      radial.h <- ifelse(nb.motifs > 200, yes = 2500, no = 2000)
      d3.lines.updated[d3.line.counter] <- gsub(pattern = "--radial_h--", x = d3l, replacement = radial.h)
    }
    
    # Insert JSON updated file
    if (grepl(pattern = "--json_file--", x = d3l)) {
      
      json.rel.path <- this.path::relpath(relative.to = results.main.dir,
                                          path = json.file)
      
      d3.lines.updated[d3.line.counter] <- gsub(pattern = "--json_file--", x = d3l, replacement = json.rel.path)
    }
    
    
    # Set the tree radium according to the number of motifs
    # NOTE: the following radius were obtained empirically
    if (grepl(pattern = "--radium--", x = d3l)) {
      
      tree.radium <- 0
      
      if (nb.motifs <= 30) {
        tree.radium = 17
      } else if (nb.motifs > 30 & nb.motifs <= 50) {
        tree.radium = 200
      } else if (nb.motifs > 50 & nb.motifs <= 100) {
        tree.radium = 250
      } else if (nb.motifs > 100 & nb.motifs <= 150) {
        tree.radium = 275
      } else if (nb.motifs >= 150 & nb.motifs <= 200) {
        tree.radium = 300
      } else if (nb.motifs >= 200) {
        tree.radium = 450;
      }
      
      # Ring annotations tart/end coordinates depend on tree's radium
      start.annotation.pos <- tree.radium + 5
      end.annotation.pos   <- (max(nchar(motif.info$name)) * 7 + 5) + ((alignment.length + 2) * 5) + 0
      end.annotation.pos   <- start.annotation.pos + end.annotation.pos
      
      
      d3.lines.updated[d3.line.counter] <- gsub(pattern = "--radium--", x = d3l, replacement = tree.radium)
    }
    
    
    # Set the motif logo height according to the number of motifs
    if (grepl(pattern = "--h_motif--", x = d3l)) {
      
      logo.height = 10
      
      if (nb.motifs <= 30) {
        logo.height <- 30
      } else if (nb.motifs > 30 & nb.motifs < 100) {
        logo.height <- 20
      } else if (nb.motifs >= 100 & nb.motifs < 500) {
        logo.height <- 10
      } else if (nb.motifs >= 500) {
        logo.height <- 5
      }
      
      d3.lines.updated[d3.line.counter] <- gsub(pattern = "--h_motif--", x = d3l, replacement = logo.height);
    }
    
    
    # Set displacement (x axis) of the logos according to the number of motifs
    if (grepl(pattern = "--x_displ--", x = d3l)) {
      
      x.displacement <- max(nchar(motif.info$name)) * 7 + 5
      
      # x.displacement <- 75
      # if (nb.motifs <= 30) {
      #   x.displacement <- 75
      # } else if (nb.motifs > 30 & nb.motifs <= 100) {
      #   x.displacement <- 70
      # } else if (nb.motifs > 100 & nb.motifs < 500) {
      #   x.displacement <- 55
      # } else if (nb.motifs >= 500) {
      #   x.displacement <- 50
      # }
      
      d3.lines.updated[d3.line.counter] <- gsub(pattern = "--x_displ--", x = d3l, replacement = x.displacement);
    }
    
    
    # Set displacement (y axis) of the logos according to the number of motifs
    if (grepl(pattern = "--y-displ--", x = d3l)) {
      
      #y.displacement <- (logo.height/2) + 3;
      y.displacement <- 0
      
      d3.lines.updated[d3.line.counter] <- gsub(pattern = "--y-displ--", x = d3l, replacement = y.displacement);
    }
    
    
    
    # Set inner ring start/end variables
    if (grepl(pattern = "--innerRad_start--", x = d3l)) {
      d3.lines.updated[d3.line.counter] <- gsub(pattern = "--innerRad_start--", x = d3l, replacement = start.annotation.pos);
    }
    
    if (grepl(pattern = "--innerRad_end--", x = d3l)) {
      d3.lines.updated[d3.line.counter] <- gsub(pattern = "--innerRad_end--", x = d3l, replacement = end.annotation.pos);
    }
    
    
    # Add path to d3 library
    if (grepl(pattern = "--d3--", x = d3l)) {
      
      # Create a copy of the D3 library in the results folder
      d3.path <- cp.d3.lib(d3     = d3.lib,
                           folder = outdir)
      
      d3.lines.updated[d3.line.counter] <- gsub(pattern = "--d3--", x = d3l, replacement = d3.path);
    }
    
    # Add path to jquery library
    if (grepl(pattern = "--jquery--", x = d3l)) {
      
      # Create a copy of the D3 library in the results folder
      jquery.path <- cp.jquery.lib(jquery = jq.lib,
                                   folder = outdir)
      
      d3.lines.updated[d3.line.counter] <- gsub(pattern = "--jquery--", x = d3l, replacement = jquery.path);
    }
  }
  
  # Export JSON file with annotations
  message("; Exporting D3 Radial tree file: ", d3.outfile)
  writeLines(d3.lines.updated, con = d3.outfile)
}


cp.d3.lib <- function(d3     = NULL,
                      folder = NULL) {
  
  message("; Creating a copy of D3 library")
  file.copy(from = dirname(d3),
            to   = folder,
            recursive = TRUE)
  
  # new.d3           <- this.path::here(.. = 1, file.path(dirname(folder), "js", basename(d3)))
  # #results.main.dir <- this.path::here(.. = 1, folder)
  # 
  # d3.radial.js <- this.path::relpath(relative.to = folder,
  #                                    path        = new.d3)
  
  return("js/d3.v3.min.js")
}


cp.jquery.lib <- function(jquery = NULL,
                          folder = NULL) {
  
  message("; Creating a copy of Jquery library")
  file.copy(from = dirname(jquery),
            to   = folder,
            recursive = TRUE)
  
  return("js/jquery.js")
}



Add_attributes_to_JSON_radial_tree <- function(motif.description.tab = NULL,
                                               clusters.list         = NULL,
                                               color.map             = NULL,
                                               htree                 = NULL,
                                               json.woa.file         = NULL,
                                               json.wa.file          = NULL,
                                               alignent.width        = NULL)  {
  
  ID_link_flag <- FALSE
  if ("url" %in% colnames(motif.description.tab)) {
    ID_link_flag <- TRUE
  }
  
  # Convert description table into a list
  motif.info.list <- motif.description.tab %>% purrr::transpose()
  names(motif.info.list) <- motif.description.tab$id
  
  # Same motif width for all logos
  motif.logo.size <- max(motif.description.tab$width)
  
  # Nodes (tree branches) to cluster association table
  node2cluster <- treenode2cluster(cluster_results = clusters.list,
                                   tree            = htree)
  
  # Motifs (tree leaves) to cluster association table
  leaf2cluster <- stack(clusters.list$clusters) %>% 
    rename("Motif"   = "values",
           "cluster" = "ind") %>% 
    data.table()
  leaf2cluster <- merge(leaf2cluster, color.map)
  
  # Read JSON file, it is stored as an array where each element corresponds to a line
  JSON.lines        <- readLines(json.woa.file)
  cluster.tree      <- "cluster_01"
  tree.branch       <- 0
  line.counter      <- 0
  tree.node         <- ""
  JSON.lines.parsed <- JSON.lines
  for (jl in JSON.lines) {
    
    # ll <- 7  # Node
    # ll <- 5  # Branch
    # ll <- 13 # LEave
    # jl <- JSON.lines[ll]
    # line.counter <- ll
    
    # Initialize
    json.flag <- 0
    line.counter <- line.counter + 1
    
    # ------------------------------------ #
    # Find the line indicating a tree leaf #
    # Update tree leaves                   #
    # ------------------------------------ #
    if (grepl(pattern = '"label":\\s*"(.+)"', jl)) {
      
      tree.label <- gsub(pattern = '"label":\\s*"(.+)"', replacement = "\\1", x = jl)
      tree.label <- gsub(pattern = "\\s+", replacement = "", x = tree.label)
      tree.label
      
      json.flag <- 1
      add.this  <- ""
      
      
      ## Define the URL of the logo files, relative to the location of the json file
      align.logo.link.relpath.F <- this.path::relpath(relative.to = results.main.dir,
                                                      path        = motif.info.list[[tree.label]]$Logo)
      align.logo.link.relpath.R <- this.path::relpath(relative.to = results.main.dir,
                                                      path        = motif.info.list[[tree.label]]$Logo_RC)
      
      ### Create the line that will be added to JSON file
      image.F.line      <- paste0(',\n "image" : "', align.logo.link.relpath.F, '"')
      image.R.line      <- paste0(',\n "image_rc" : "', align.logo.link.relpath.R, '"')
      url.line          <- paste0(',\n "url" : "', align.logo.link.relpath.F, '"')
      ic.line           <- paste0(',\n "ic" : ', round(motif.info.list[[tree.label]]$IC, digits = 3))
      size.line         <- paste0(',\n "size" : ', alignent.width)
      name.line         <- paste0(',\n "name" : "', motif.info.list[[tree.label]]$name, '"')
      branch.color.line <- paste0(',\n "branch_color" : "', as.vector(subset(leaf2cluster, Motif == tree.label)$color), '"')
      
      
      
      add.this <- paste0(image.F.line,
                         image.R.line,
                         url.line,
                         ic.line,
                         size.line,
                         name.line,
                         branch.color.line)
      
      # This needs to be completed
      if (ID_link_flag) {
        
        link.ext.line <- paste0(',\n "url" : "', motif.info.list[[tree.label]]$url, '"')
        color.line    <- paste0(',\n "color" : "', motif.info.list[[tree.label]]$colour, '"')
        
        add.this <- paste0(add.this,
                           link.ext.line,
                           color.line)
      }
      
      JSON.lines[line.counter] <- paste0(jl, add.this)
    }
    
    # -------------------------------------- #
    # Find the line indicating a tree branch #
    # Update tree branches                   #
    # -------------------------------------- #
    if (grepl(pattern = '"node"\\s*:', jl)) {
      tree.node <- gsub(pattern = '"node":"(node_\\d+)",', replacement = "\\1", x = jl)
      tree.node <- gsub(pattern = "\\s+", replacement = "", x = tree.node)
    }
    
    if (grepl(pattern = '"children"\\s*:', jl)) {
      
      # Update variables
      tree.branch     <- tree.branch + 1
      add.branch.line <- ""
      
      if (tree.branch > 1) {
        
        tree.label <- gsub(pattern = '"label":\\s*"(.+)"', replacement = "\\1", x = jl)
        tree.label <- gsub(pattern = "\\s+", replacement = "", x = tree.label)
        
        # Check this node_to_cluster_hash variable
        # Check that nodes without clusters have a different color
        branch.color <- '#ccc;'
        
        
        node.cluster <- as.vector(subset(node2cluster, node == tree.node)$cluster)
        #print(tree.node)
        # print(node.cluster)
        #print(line.counter)
        if (grepl(pattern = 'node_\\d+', x = tree.node)) {
          branch.color <- as.vector(subset(leaf2cluster, cluster == node.cluster)$color)
        }
        
        
        add.branch.line <- paste0('"branch_color" : "', branch.color, '",\n')
        
        #JSON.lines.parsed <- append(JSON.lines.parsed, add.branch.line, after = line.counter)
        JSON.lines[line.counter] <- paste0(add.branch.line, jl)
      }
    } # end of children grepl if
  } # End for loop
  
  # Export JSON file with annotations
  message("; Exporting JSON file with annotations: ", json.wa.file)
  writeLines(JSON.lines, con = json.wa.file)
  
}



annotate.radial.tree <- function(clusters         = NULL,
                                 cluster2color    = NULL,
                                 tree             = NULL,
                                 motif.annotation = NULL) {
  
  suppressMessages(library(jsonlite))
  
  # Motifs (tree leaves) to cluster association table
  treeleaf2cluster <- stack(clusters) %>%
    rename("Motif"   = "values",
           "cluster" = "ind") %>%
    data.table()
  
  # Cluster::Motif::Cluster-color mapping table
  treeleaf2cluster <- merge(treeleaf2cluster, cluster2color)
  
  # Map motif IDs
  matrix_order.df <- tree$labels[tree$order]
  matrix_order.df <- treeleaf2cluster[match(matrix_order.df, treeleaf2cluster$Motif), ] |>
    select(Motif, color) |>
    rename(motif_id    = Motif,
           cluster_nb  = color) |>
    mutate(id_motif = 1:nrow(treeleaf2cluster))
  
  # Read and parse annotation file
  motif.annotation$class      <- gsub("'", "", as.character(motif.annotation$class))
  motif.annotation$collection <- gsub("\"", "", as.character(motif.annotation$collection))
  motif.annotation$motif_id   <- gsub("\"", "", as.character(motif.annotation$motif_id))
  
  
  # matrix_element <- annotation.df[1,]
  # rm(matrix_element)
  annotation.merge.df <- apply(motif.annotation, 1 ,function(matrix_element){
    
    # Create regex
    #regex_string    <- paste0("^", matrix_element["collection_name"], "_m\\d+_", matrix_element["matrix_name"],"_n+\\d+$")
    regex_string <- matrix_element["motif_id"]
    # message(regex_string)
    
    # NOTE WSG: spcial character from regex must be forbidden in
    # the file names. Need to add a sanity check
    # Safe check for special characters in regex
    #regex_string <- sub("\\+", "\\\\+", regex_string)
    
    # Find complete motif name
    match_matrix.df <- matrix_order.df[grepl(regex_string, as.character(matrix_order.df$motif_id)), ]
    # print(match_matrix.df)
    
    # Transpose match
    matrix_element <- as.data.frame(t(as.data.frame(matrix_element)))
    
    # Add annotation columns to matched matrix
    match_matrix.df <- cbind(match_matrix.df, matrix_element)
    
    return(match_matrix.df)
  }) %>% (plyr::rbind.fill)
  
  message("; Calculating degrees intervals for each annotation layer.")
  
  # Sort the data frame by id_motif
  annotation.merge.df       <- annotation.merge.df[order(annotation.merge.df$id_motif),]
  annotation.merge.df$start <- (0:(dim(annotation.merge.df)[1] - 1)) * (360/dim(annotation.merge.df)[1])
  annotation.merge.df$end   <- (1:(dim(annotation.merge.df)[1])) * (360/dim(annotation.merge.df)[1])
  
  # Convert annotation DF to JSON format
  annotation.json <- toJSON(annotation.merge.df)
  
  message("; Annotating JSON file")
  output.files.list$annotation_json_file  <- file.path(out.folder.list$trees, "annotation_matrix.json")
  write_json(annotation.json, output.files.list$annotation_json_file)
  
  prefix <- gsub(output.files.list$D3_radial_tree, pattern = "_D3_radial_tree.html", replacement = "")
  python_script_path = file.path(this.path::here(.. = 0), "annotate-html-radialtree.py")
  cmd_annotate_htmltree <- paste0("python3 ", python_script_path,
                                  " -i ", prefix)
  
  # Launch annotation script
  # Walter Santana wrote this script in python
  # It works for the moment but ideally we should convert the script to R code 
  #print(cmd_annotate_htmltree)
  system(cmd_annotate_htmltree)
}



create.color.annotation <- function(motif.meta.file = NULL,
                                    ann.outdir      = NULL) {
  
  # ---------------------------- #
  # Read and parse metadata file #
  # ---------------------------- #
  message("; Reading motif metadata table")
  motif.meta <- fread(motif.meta.file)
  
  ## For the dimers considers only the first TF class
  motif.meta$class <- gsub(motif.meta$class, pattern = ",.+$", replacement = "", perl = T)
  motif.meta$class <- gsub(motif.meta$class, pattern = "::.+$", replacement = "", perl = T)
  
  ## Add the 'Unknown' TF class to entries without a class
  motif.meta$class <- ifelse(motif.meta$class == "", yes = "Unknown", no = motif.meta$class)
  
  
  # --------------------- #
  # Create TF-class table #
  # --------------------- #
  
  
  ## Get the TF class names ordered by number of motifs
  TF.class.order <- motif.meta %>% 
    group_by(class) %>% 
    tally() %>% 
    arrange(desc(n)) %>% 
    dplyr::filter(class != "Unknown")
  TF.class.order <- TF.class.order$class  
  
  
  # ---------------------------- #
  # TF class - Color assignation #
  # ---------------------------- #
  message("; Assigning colours to TF classes")
  
  TF.known.classes    <- TF.class.order
  TF.known.classes.nb <- length(TF.known.classes)
  
  ## Grey color for Unknown class
  unknown.class.color <- "#888888"
  
  nb.classes.palette <- 12  ## We want to use the first 12 colors of the Safe palette
  nb.seed.colors     <- ifelse(TF.known.classes.nb < nb.classes.palette,
                               yes = TF.known.classes.nb,
                               no = nb.classes.palette)
  
  ## Generate a carto palette (remove gray value)
  carto.pal.classes  <- carto_pal(nb.seed.colors, "Safe")
  carto.pal.classes  <- carto.pal.classes[which(carto.pal.classes != "#888888")]
  
  ## Expand the color palette and add the gray color at the end
  class.colors        <- c(colorRampPalette(carto.pal.classes, space = "Lab")(TF.known.classes.nb),
                           unknown.class.color)
  names(class.colors) <- c(TF.known.classes, "Unknown")
  df.class.colour     <- data.frame(colour   = class.colors,
                                    class    = names(class.colors),
                                    class_nb = seq_len(TF.known.classes.nb + 1)) 
  
  
  
  # --------------------------- #
  # TF_class::Colour HTML table #
  # --------------------------- #
  
  ## Table header + tail
  head.tab <- "<div id='Color_class_tab' style='display: inline-block;float:left;position:relative;' class='color-legend' width='450px'><p style='font-size:12px;padding:0px;border:0px'><b></b></p><table id='Color_class_table' class='Color_class_table hover compact stripe' cellspacing='0' width='450px' style='padding:15px;align:center;font-family:arial'><thead><tr><th > Color </th> <th> TF Class </th> <th> Number</th> </tr></thead><tbody>"
  tab.lines <- paste("\n<tr><td class='color-box' style='background-color: --color--';></td> <td>--TFClass--</td> <td>--TFClass_ID--</td> </tr>", collapse = "")
  tail.tab <- "<tr><td class='non_validated'>*</td><td>Unvalidated</td></tr></tbody></table></div>"
  
  
  ## Table body
  table.body <- sapply(1:nrow(df.class.colour), function(r.nb){
    
    ## Set variables
    tab.lines.current.line <- tab.lines
    TF.class.Color <- df.class.colour[r.nb,1]
    TF.class.Name  <- df.class.colour[r.nb,2]
    TF.class.ID    <- df.class.colour[r.nb,3]
    
    tab.lines.current.line <- gsub("--TFClass--", TF.class.Name, tab.lines.current.line)
    tab.lines.current.line <- gsub("--color--", TF.class.Color, tab.lines.current.line)
    tab.lines.current.line <- gsub("--TFClass_ID--", TF.class.ID, tab.lines.current.line)
    
  })
  table.body <- paste(table.body, collapse = "")
  
  html.table <- paste(head.tab, table.body, tail.tab, collapse = "")
  html.annotation.table <- file.path(ann.outdir, "Radial_tree_legend.html")
  message("; Radial tree HTML legend : ", html.annotation.table)
  writeLines(html.table, html.annotation.table)
  
  
  # --------------------- #
  # Export metadata table #
  # --------------------- #
  
  ## Combine tables
  motif.meta.colour <- merge(motif.meta, df.class.colour, by = "class") |> 
    select(collection, motif_id, colour, class, class_nb, url)
  
  annotation.table.file <- file.path(ann.outdir, "annotation_table.txt")
  message("; Motif annotation table : ", annotation.table.file)
  fwrite(motif.meta.colour, file = annotation.table.file, sep = "\t")
  
  return(list(df   = motif.meta.colour,
              html = html.table,
              cpal = class.colors))
}


which.collection <- function(id = NULL) {
  
  if (grepl(id, pattern = "MA\\d+\\.\\d+" )) {
    return("CORE")
  } else if (grepl(id, pattern = "UN\\d+\\.\\d+")) {
    return("UNVALIDATED")
  } else {
    return("None")
  }
}
wc <- Vectorize(which.collection)



# This function exports a barplot (jpeg) with the number of motifs in each class
annotation.barplot <- function(df            = NULL,
                               class.colors  = NULL,
                               barplot.title = NULL,
                               barplot.file  = NULL) {
  
  # Init
  collection.type <- NULL
  has.MA          <- NULL
  has.UN          <- NULL
  alpha.values    <- NULL
  y.axis.lab      <- NULL
  
  # Sort classes by number of TFs
  # Unkown classes at the end of the vector
  TF.class.sorted <- names(sort(table(df$class), decreasing = TRUE))
  TF.class.sorted <- TF.class.sorted[!TF.class.sorted %in% "Unknown"]
  TF.class.sorted <- c(TF.class.sorted, "Unknown")
  
  df$class <- factor(df$class, levels = rev(TF.class.sorted))

  # Sort and factorize collections for display purposes in TF.class.barplot
  unique.collections        <- unique(df$collection)
  unique.collections.sorted <- unique.collections[order(unique.collections, decreasing = T)]
  df$collection             <- factor(df$collection, levels = unique.collections.sorted)
  
  # Check format of motif IDs (this is specific for JASPAR motifs)
  has.MA <- sum(as.vector(sapply(motif.annotation.list$df$motif_id, grepl, pattern = "MA\\d+\\.\\d+"))) > 0
  has.UN <- sum(as.vector(sapply(motif.annotation.list$df$motif_id, grepl, pattern = "UN\\d+\\.\\d+"))) > 0
  
  if (has.MA & !has.UN) {
    collection.type <- "CORE"
  } else if (has.MA & has.UN) {
    collection.type <- "UNVALIDATED"
  } else {
    collection.type <- "None"
  }
  
  ## This dataframe contains the labels to be displayed on each bar
  ## Adapt to collection type
  if (collection.type %in%  c("CORE", "UNVALIDATED")) {
    label.df <- df |> 
      mutate(type = wc(motif_id)) |> 
      group_by(class) %>% 
      mutate(Total_Class = n()) %>%
      group_by(class, type) |> 
      mutate(COREc = sum(type %in% "CORE"),
             UNVc  = sum(type %in% "UNVALIDATED")) %>% 
      select(class, COREc, UNVc) %>% 
      distinct() %>% 
      ungroup() %>% 
      group_by(class) %>% 
      mutate(CORE        = max(COREc),
             UNVALIDATED = max(UNVc)) %>% 
      select(class, CORE, UNVALIDATED) %>% 
      distinct()
    
  } else {
    label.df <- df |> 
      mutate(type = wc(motif_id)) |> 
      group_by(class) %>% 
      mutate(Total_Class = n()) %>%
      group_by(class, type) |> 
      mutate(COREc = sum(type %in% "None")) %>% 
      select(class, COREc) %>% 
      distinct() %>% 
      ungroup() %>% 
      group_by(class) %>% 
      mutate(CORE        = max(COREc)) %>% 
      select(class, CORE) %>% 
      distinct()
  }
  
  
  if (collection.type == "UNVALIDATED") {
    
    label.df <- label.df %>% 
      mutate(lab         = paste0(UNVALIDATED, "/", CORE),
             Total_Class = sum(c(CORE, UNVALIDATED))) %>% 
      data.table()
    
  } else if (collection.type %in% c("CORE", "None")) {
    
    label.df <- label.df %>% 
      mutate(lab         = CORE,
             Total_Class = sum(CORE)) %>% 
      data.table()
  }
  
  
  ## Use this variable to have enough space to insert the labels
  max.y <- max(label.df$Total_Class) + 25
  
  
  ## The alpha parameter and plot title change depending on the collection type
  if (collection.type == "UNVALIDATED") {
    alpha.values  <- c(0.4, 1)
    y.axis.lab    <- "Number of motifs (Unvalidated/Core)"
  } else if (collection.type == "CORE") {
    alpha.values  <- 1
    y.axis.lab    <- "Number of motifs (CORE)"
  } else if (collection.type == "None") {
    alpha.values  <- 1
    y.axis.lab    <- "Number of motifs"
  }
  
  TF.class.barplot <- ggplot(df, aes(alpha = collection, x = class, fill = class)) +
    geom_bar() +
    coord_flip() +
    scale_fill_manual(values = class.colors) +
    theme_classic() +
    labs(x = "TF class", y = y.axis.lab, title = barplot.title) +
    scale_alpha_manual(values = alpha.values) +
    theme(text        = element_text(size = 15),
          axis.text.y = element_text(angle = 0, hjust = 1, size = 10),
          axis.text.x = element_text(hjust = 0.5, size = 15),
          legend.position = "none",
          legend.title    = element_blank(),
          legend.text     = element_text(size = 9),
          legend.box      = "vertical",
          plot.title      = element_text(hjust = 0.5),
          panel.grid.major.x = element_line(color = "#969696",
                                            size = 0.25,
                                            linetype = 2)) +
    geom_text(data = label.df, aes(x = class, y = Total_Class, label = lab), vjust = 0.5, hjust = -0.2, inherit.aes = F, size = 3.5) +
    guides(fill = guide_legend(reverse = T))  +
    scale_y_continuous(limits = c(0, max.y), expand = c(0,2), breaks = seq(0, max.y, by = 50)[-1])
  
  ggsave(plot     = TF.class.barplot,
         filename = barplot.file,
         width    = 12,
         height   = 8)
  message("; Class barplot created: ", barplot.file)
  
  
  ## Convert ggplot to plotly
  TF.class.barplotly <- ggplotly(TF.class.barplot,
                                 tooltip = c("alpha", "x", "y")) %>% 
                          config(displayModeBar = F)
  
  
  ###################################################
  ## Export barplot: interactive and static format ##
  ###################################################
  
  # Same name, different extension (svg -> html)
  TF.class.barplotly.html <- gsub(barplot.file, pattern = "\\.svg", replacement = "\\.html")
  
  htmlwidgets::saveWidget(widget = TF.class.barplotly,
                          file   = TF.class.barplotly.html, selfcontained = F)
}



# cluster_name          = "cluster_11"
# cluster_name          = "cluster_01"
# motif.description.tab = results.list$Motif_info_tab  # Subset of the table including only the motifs in a cluster
# clusters.list         = find.clusters.list
# color.map             = cl.col
# htree                 = cl.hclust.results
# json.file.df          = results.list$Clusters_files
# alignment.df          = results.list$Alignment_table

Add_attributes_to_JSON_interactive_tree <- function(cluster_name          = NULL,
                                                    motif.description.tab = NULL,  # Subset of the table including only the motifs in a cluster
                                                    clusters.list         = NULL,
                                                    color.map             = NULL,
                                                    htree                 = NULL,
                                                    json.file.df          = NULL,
                                                    alignment.df          = NULL) {
 
  # Singletons are treated differently
  cl.motifs      <- clusters.list$clusters[[cluster_name]]
  singleton.flag <- ifelse(length(cl.motifs) == 1, TRUE, FALSE)

  
  # Select entries
  motif.description.tab <- motif.description.tab |> dplyr::filter(id %in% cl.motifs)
  # htree                 <- htree[[cluster_name]]$hclust
  json.woa.file         <- subset(json.file.df, Cluster == cluster_name)$JSON_file
  json.wa.file          <- subset(json.file.df, Cluster == cluster_name)$JSON_annotated_file
  alignment.width       <- max(subset(alignment.df, cluster == cluster_name)$width)
  

  # Convert description table into a list
  motif.info.list <- motif.description.tab %>% purrr::transpose()
  names(motif.info.list) <- motif.description.tab$id

  # Same motif width for all logos
  motif.logo.size <- max(motif.description.tab$width)

  # Nodes (tree branches) to cluster association table
  # node2cluster <- treenode2cluster(cluster_results = clusters.list,
  #                                  tree            = htree)

  # Motifs (tree leaves) to cluster association table
  leaf2cluster <- stack(clusters.list$clusters) %>%
                    rename("Motif"   = "values",
                           "cluster" = "ind") %>%
                    data.table()
  leaf2cluster <- merge(leaf2cluster, color.map)

  # Read JSON file, it is stored as an array where each element corresponds to a line
  JSON.lines        <- readLines(json.woa.file)
  tree.branch       <- 0
  line.counter      <- 0
  tree.node         <- ""
  JSON.lines.parsed <- JSON.lines
  for (jl in JSON.lines) {
    
    #[5] " \"label\": \"JASPAR_nematodes_MA0264.1_n5\","
    
    # line.counter <- 7
    # line.counter <- 5
    # jl <- JSON.lines[line.counter]

    # Initialize
    json.flag <- 0
    line.counter <- line.counter + 1

    # ------------------------------------ #
    # Find the line indicating a tree leaf #
    # Update tree leaves                   #
    # ------------------------------------ #
    if (grepl(pattern = '"label":\\s*"(.+)"', jl)) {

      tree.label <- gsub(pattern = '"label":\\s*"(.+)"', replacement = "\\1", x = jl)
      tree.label <- gsub(pattern = "\\s+", replacement = "", x = tree.label)
      json.flag  <- 1
      add.this   <- ""


      ## Define the URL of the logo files, relative to the location of the json file
      align.logo.link.relpath.F <- this.path::relpath(relative.to = results.main.dir,
                                                      path        = motif.info.list[[tree.label]]$Logo)
      align.logo.link.relpath.R <- this.path::relpath(relative.to = results.main.dir,
                                                      path        = motif.info.list[[tree.label]]$Logo_RC)

      ### Create the line that will be added to JSON file
      image.F.line      <- paste0(',\n      "image" : "', align.logo.link.relpath.F, '"')
      image.R.line      <- paste0(',\n      "image_rc" : "', align.logo.link.relpath.R, '"')
      ic.line           <- paste0(',\n      "ic" : ', round(motif.info.list[[tree.label]]$IC, digits = 3))
      size.line         <- paste0(',\n      "size" : ', alignment.width)
      name.line         <- paste0(',\n      "name" : "', motif.info.list[[tree.label]]$name, '"')
      branch.color.line <- paste0(',\n      "branch_color" : "', as.vector(subset(leaf2cluster, Motif == tree.label)$color), '"')

      add.this <- paste0(image.F.line,
                         image.R.line,
                         ic.line,
                         size.line,
                         name.line,
                         branch.color.line)

      JSON.lines[line.counter] <- paste0(jl, add.this)
    }

    # -------------------------------------- #
    # Find the line indicating a tree branch #
    # Update tree branches                   #
    # -------------------------------------- #
    if (grepl(pattern = '"node"\\s*:', jl)) {
      tree.node <- gsub(pattern = '"node":"(node_\\d+)",', replacement = "\\1", x = jl)
      tree.node <- gsub(pattern = "\\s+", replacement = "", x = tree.node)
    }

    if (grepl(pattern = '"children"\\s*:', jl)) {

      # Update variables
      tree.branch     <- tree.branch + 1
      add.branch.line <- ""

      if (tree.branch > 1) {

        tree.label <- gsub(pattern = '"label":\\s*"(.+)"', replacement = "\\1", x = jl)
        tree.label <- gsub(pattern = "\\s+", replacement = "", x = tree.label)

        # Check this node_to_cluster_hash variable
        # Check that nodes without clusters have a different color
        branch.color <- '#ccc;'

        # node.cluster <- as.vector(subset(node2cluster, node == tree.node)$cluster)
        # 
        # if (grepl(pattern = 'node_\\d+', x = tree.node)) {
        #   branch.color <- as.vector(subset(leaf2cluster, cluster == node.cluster)$color)
        # }


        add.branch.line <- paste0('"branch_color" : "', branch.color, '",\n')

        #JSON.lines.parsed <- append(JSON.lines.parsed, add.branch.line, after = line.counter)
        JSON.lines[line.counter] <- paste0(add.branch.line, jl)
      }
    } # end of children grepl if
  } # End for loop

  # Export JSON file with annotations
  # message("; Exporting JSON file with annotations: ", json.wa.file)
  writeLines(JSON.lines, con = json.wa.file)

}



# clusters      = find.clusters.list$clusters
# clusters.df   = results.list$Clusters_files
# html.template = html.interactive.tree.template
# d3.template   = d3.interactive.tree.template
# cluster.color = cl.col
# outdir        = dirname(out.folder)
# hmtl.ready    = output.files.list$D3_dynamic_tree


create.html.interactive.tree <- function(clusters         = NULL,
                                         collection.names = NULL,
                                         clusters.df      = NULL,
                                         cluster.color    = NULL,
                                         html.template    = NULL,
                                         hmtl.ready       = NULL,
                                         d3.template      = NULL,
                                         d3.lib           = NULL,
                                         jq.lib           = NULL,
                                         outdir           = NULL) {

  # Read d3 template (same for each cluster)
  d3.lines <- readLines(d3.template)

  # --------------------------------------------------------------- #
  # For each cluster creates a D3 tree object with its own features #
  # (logo, name, color, IC, etc)                                    #
  # Save these D3 trees as a single string                          #
  # --------------------------------------------------------------- #


  # cl        <- "cluster_01"
  # cl.motifs <- clusters[[cl]]
  #
  # cl.name = cl
  # cl.col  = subset(cluster.color, cluster == cl)$color
  # # cl.col  = cluster.color
  # cl.comp = cl.motifs
  # d3.vec  = d3.lines
  # json.file = subset(clusters.df, Cluster == cl.name)$JSON_annotated_file
  
  # Max number of characters in motif IDs
  # This is needed to calculate the distance between trees and logos
  motifids <- as.vector(unlist(clusters))
  motifids <- sapply(motifids, gsub, pattern = "_n\\d+$", replacement = "")
  for (cn in collection.names) {
    motifids <- sapply(motifids, gsub, pattern = paste0("^", cn, "_"), replacement = "")
  }
  nb.char  <- max(nchar(motifids))

  d3.trees.code <- purrr::map(.x = names(clusters),
  # d3.trees.code <- purrr::map(.x = c("cluster_01"),
                              .f = ~d3.tree.one.cluster(cl.name   = .x,
                                                        cl.color  = subset(cluster.color, cluster == .x)$color,
                                                        cl.comp   = clusters[[.x]],
                                                        d3.vec    = d3.lines,
                                                        id.nchar  = nb.char,
                                                        json.file = subset(clusters.df, Cluster == .x)$JSON_annotated_file))
  d3.trees.code <- paste0(d3.trees.code, collapse = "\n\n")

  # -------------- #
  # Cluster ID DIV #
  # -------------- #
  cluster.id.div <- paste0('<div id="', names(clusters), '_button" style="clear:both;border-left:100px;float:left;"><h2>', names(clusters), '</h2><div id="', names(clusters), '"></div></div><br><br><br>', collapse = "\n")

  # Insert the D3 trees in the HTML template
  html.lines <- readLines(html.template)
  html.lines.updated <- html.lines
  html.line.counter <- 0
  for (html in html.lines) {

    html.line.counter <- html.line.counter + 1

    # Add path to d3 library
    if (grepl(pattern = "--d3--", x = html)) {

      # Create a copy of the D3 library in the results folder
      d3.path <- cp.d3.lib(d3     = d3.lib,
                           folder = outdir)

      html.lines.updated[html.line.counter] <- gsub(pattern = "--d3--", x = html, replacement = d3.path);
    }

    # Add path to jquery library
    if (grepl(pattern = "--jquery--", x = html)) {

      # Create a copy of the D3 library in the results folder
      jquery.path <- cp.jquery.lib(jquery = jq.lib,
                                   folder = outdir)

      html.lines.updated[html.line.counter] <- gsub(pattern = "--jquery--", x = html, replacement = jquery.path);
    }

    # Add DIV clusters
    if (grepl(pattern = "--div_clusters--", x = html)) {

      html.lines.updated[html.line.counter] <- gsub(pattern = "--div_clusters--", x = html, replacement = cluster.id.div)
    }


    # Add D3 tree code
    if (grepl(pattern = "--d3_trees--", x = html)) {

      html.lines.updated[html.line.counter] <- gsub(pattern = "--d3_trees--", x = html, replacement = d3.trees.code)
    }
  }

  # Export JSON file with annotations
  message("; Exporting dynamic html tree file: ", hmtl.ready)
  writeLines(html.lines.updated, con = hmtl.ready)
}



# This functions returns the D3 code updated for a particular cluster
# It also returns the HTML Div tag containing the D3 code
d3.tree.one.cluster <- function(cl.name   = NULL,
                                cl.comp   = NULL,
                                cl.color  = NULL,
                                d3.vec    = NULL,
                                id.nchar  = NULL,
                                json.file = NULL) {

  cl.size <- length(cl.comp)


  # ---------------------------------------- #
  # Complete the missing annotation elements #
  # ---------------------------------------- #
  
  # Adapt font-size according to the number of characters
  # This is a quick solution, we don't expect to have such long motif names, but in a few cases we have them.
  # So this if block can be easily extended to adapt to these cases
  font.size.dynamic.tree <- 20
  if (id.nchar > 35) {
    font.size.dynamic.tree <- 16
  }
  
  d3.annotation.list <- list(JSON_string = NULL,
                             widthtree   = 1500,
                             heighttree  = NULL,
                             size        = 350,
                             cl_id       = cl.name,
                             sep_motifs  = NULL,
                             stroke      = cl.color,
                             logowidth   = 15,
                             logoheight  = 13,
                             font_size   = font.size.dynamic.tree,
                             x_logo      = NULL,
                             y_logo      = NULL)

  # This is the JSON inserted in the D3 template
  d3.annotation.list$JSON_string <- paste0(readLines(json.file), collapse = "\n")

  # Tree width/height
  d3.annotation.list$widthtree <- 1500
  d3.annotation.list$heighttree <- 100 * cl.size
  # d3.annotation.list$size      <- 350           # d3.layout.cluster()

  # Space between motifs
  d3.annotation.list$sep_motifs <- case_when(cl.size <   5 ~ 150,
                                             cl.size <=  9 ~ 200,
                                             cl.size <= 20 ~ 250,
                                             cl.size <= 50 ~ 300,
                                             TRUE ~ 420  # Default value if none of the cases match
  )

  # Values for logo displacement
  gap.logo                  <- 0.66
  d3.annotation.list$x_logo <- (id.nchar * d3.annotation.list[['font_size']]) * gap.logo
  d3.annotation.list$y_logo <- -40


  # ------------------------------------------------ #
  # Replace placeholders by variables in D3 template #
  # ------------------------------------------------ #
  # d3l <- d3.vec[2]
  line.counter <- 0
  for (d3l in d3.vec) {

    line.counter <- line.counter + 1

    # Replace placeholders in D3 template
    if (grepl("--\\w+--", d3l)) {

      # Placeholder names are the same as the fields in d3.annotation.list
      d3l.cp <- gsub(x = d3l, pattern = "^.+--(\\w+)--.+$", replacement = "\\1")
      #print(d3l.cp)
      d3l    <- gsub(x = d3l, pattern = "--\\w+--", replacement = d3.annotation.list[[d3l.cp]])
      # print(d3l)
      d3.vec[line.counter] <- d3l
    }
  }

  return(paste0(d3.vec, collapse = "\n"))
}
